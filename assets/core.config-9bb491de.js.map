{"version":3,"file":"core.config-9bb491de.js","sources":["../../src/core/config/utils.ts","../../src/core/config/index.ts"],"sourcesContent":["import type { TComponentId } from '@/@types/components';\n\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Serializes components by dependency ordering using Topological Sorting.\n * @param components list of objects of component identifier and dependent component identifiers\n * @returns component identifiers in serialized order\n */\nexport function serializeComponentDependencies(\n    components: { id: TComponentId; dependencies: TComponentId[] }[],\n): TComponentId[] {\n    const length = components.length;\n\n    /**\n     * Generates a Directed Acyclic Graph (DAG) of the component indices.\n     * @returns a `nxn` matrix representing the DAG in adjacent list form\n     *\n     * @description\n     * Consider there are five components (`a`, `b`, `c`, `d`, `e`). `b` is child of `a`, `c` is\n     * child of `b`, `e` is child of `b` and `d`.\n     * The DAG will be:\n     * a <-- b <-- c\n     *       ^\n     *       |\n     * d <-- e\n     * The DAG matrix returned will be:\n     *   ____a_____b_____c_____d_____e____\n     * a | false false false false false |\n     * b |  true false false false false |\n     * c | false  true false false false |\n     * d | false false false false false |\n     * e | false  true false  true false |\n     *   ---------------------------------\n     * A cell (`row`, `col`) represents if component with index `row` is a child of component with\n     * index `col`.\n     */\n    const createDAG = () => {\n        const DAG = new Array<boolean[]>(length);\n\n        for (let i = 0; i < length; i++) {\n            const rowComponent = components[i];\n            DAG[i] = new Array<boolean>(length);\n            DAG[i].fill(false);\n\n            for (let j = 0; j < length; j++) {\n                const colComponent = components[j];\n\n                if (rowComponent.dependencies.includes(colComponent.id)) {\n                    DAG[i][j] = true;\n                }\n            }\n        }\n\n        return DAG;\n    };\n\n    const DAG = createDAG();\n\n    /**\n     * Serializes the generated DAG using Topological Sorting such that child component indices\n     * appear after their parent component indices in the ordering\n     * @returns a list of serialized indices of the DAG\n     *\n     * @description\n     * For the example above (function `createDAG` description), the result will be\n     * `[0, 3, 1, 2, 4]` representing component order [`a`, `d`, `b`, `c`, `e`].\n     */\n    const serializeDAG = () => {\n        let visited: number[] = [];\n        let visiting: number[] = [];\n        let unvisited: number[] = components.map((_, i) => i);\n\n        while (unvisited.length > 0) {\n            // find nodes with no parents\n            for (let i = 0; i < length; i++) {\n                let hasParents = false;\n\n                for (let j = 0; j < length; j++) {\n                    if (DAG[i][j] === true) {\n                        hasParents = true;\n                        break;\n                    }\n                }\n\n                // if node has no parents and node wasn't visited\n                if (!hasParents && !visited.includes(i)) {\n                    // add node to visitng list\n                    visiting.push(i);\n                    // remove node from unvisited list\n                    unvisited.splice(\n                        unvisited.findIndex((index) => index === i),\n                        1,\n                    );\n                }\n            }\n\n            // edge case for cyclic graph (or subgraph)\n            if (visiting.length === 0) {\n                throw Error('Invalid Config: dependency resolution results in a cyclic graph');\n            }\n\n            // for visiting nodes in order\n            for (const index of visiting) {\n                // add node to visited list\n                visited.push(index);\n\n                // remove all edges (in DAG) to node\n                for (let j = 0; j < length; j++) {\n                    DAG[j][index] = false;\n                }\n            }\n\n            // clear visiting list\n            visiting = [];\n        }\n\n        return visited;\n    };\n\n    const serializedIndices = serializeDAG();\n\n    return serializedIndices.map((i) => components[i].id);\n}\n\n// -------------------------------------------------------------------------------------------------\n\n/*\n * dummy config to debug valid topological sorting\n *   a <-- b <-- c\n *         ^\n *         |\n *   d <-- e\n */\n\n// serializeComponentDependencies([\n//     // @ts-ignore\n//     { id: 'a', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'b', dependencies: ['a'] },\n//     // @ts-ignore\n//     { id: 'c', dependencies: ['b'] },\n//     // @ts-ignore\n//     { id: 'd', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'e', dependencies: ['b', 'd'] },\n// ]).forEach((componentId) => console.log(componentId));\n\n/*\n * dummy config to debug invalid (cycle in `b`, `c`, `e`) topological sorting\n *   a <-- b <-- c\n *         |     ^\n *         v     |\n *   d <-- e ----\n */\n\n// serializeComponentDependencies([\n//     // @ts-ignore\n//     { id: 'a', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'b', dependencies: ['e'] },\n//     // @ts-ignore\n//     { id: 'c', dependencies: ['b'] },\n//     // @ts-ignore\n//     { id: 'd', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'e', dependencies: ['d', 'd'] },\n// ]).forEach((componentId) => console.log(componentId));\n","import type { IComponent, TComponentId, TComponentManifest } from '@/@types/components';\nimport type { IElementSpecification } from '@sugarlabs/musicblocks-v4-lib';\n\nimport {\n    registerElementSpecificationEntries,\n    librarySpecification,\n} from '@sugarlabs/musicblocks-v4-lib';\n\n// -- private variables ----------------------------------------------------------------------------\n\n/** Stores key-value pairs of component identifier and component module. */\nconst _components: Partial<Record<TComponentId, IComponent>> = {};\n\n// -- private functions ----------------------------------------------------------------------------\n\n/**\n * Mounts a component module.\n * @param componentId component identifier\n */\nasync function _mountComponent(componentId: TComponentId): Promise<void> {\n    const component = _components[componentId]!;\n    await component.mount();\n}\n\n/**\n * Initializes a component module.\n * @param componentId component identifier\n */\nasync function _setupComponent(componentId: TComponentId): Promise<void> {\n    const component = _components[componentId]!;\n    await component.setup();\n}\n\n// -- public functions -----------------------------------------------------------------------------\n\n/**\n * Returns a component module by it's identifier.\n * @param componentId component identifier\n * @returns component module if valid identifier else `null`\n */\nexport function getComponent(componentId: TComponentId): IComponent | null {\n    return componentId in _components ? _components[componentId]! : null;\n}\n\n/**\n * Imports a component module.\n * @param componentId component identifier\n * @param path path to the module relative to `src/components`\n * @returns a Promise to the component's module\n */\nexport async function importComponent(\n    componentId: TComponentId,\n    path: string,\n): Promise<IComponent> {\n    _components[componentId] = await import(`../../components/${path}/index.ts`);\n    return _components[componentId]!;\n}\n\n/**\n * Imports a list of component modules asynchronously.\n * @param componentIds list of component identifiers\n * @param callback callback function to call after succesful import of each component's module\n * @returns a Promise to the component module map\n */\nexport async function importComponents(\n    componentIds: TComponentId[],\n    componentManifest: TComponentManifest,\n    callback?: (componentId: TComponentId) => unknown,\n): Promise<Partial<Record<TComponentId, IComponent>>> {\n    Object.fromEntries(\n        await Promise.all(\n            componentIds\n                .map((id) => [id, componentManifest[id].path] as [TComponentId, string])\n                .map(([id, path]) =>\n                    importComponent(id, path).then((component) => {\n                        if (callback !== undefined) callback(id);\n                        return [id, component];\n                    }),\n                ),\n        ),\n    );\n\n    return _components;\n}\n\n/**\n * Mounts a list of component modules synchronously.\n * @param entries list of tuples of component identifiers and feature flags\n * @param callback callback function to call after succesful mounting of each component\n */\nexport async function mountComponents(\n    componentIds: TComponentId[],\n    callback?: (componentId: TComponentId) => unknown,\n): Promise<void> {\n    return new Promise((resolve) => {\n        const iterator = componentIds.entries();\n\n        async function _mountHelper(\n            iteratorResult: IteratorResult<[number, TComponentId], unknown>,\n        ): Promise<void> {\n            if (iteratorResult.done) return;\n\n            const [_, componentId] = iteratorResult.value;\n            await _mountComponent(componentId);\n            if (callback !== undefined) callback(componentId);\n\n            return _mountHelper(iterator.next());\n        }\n\n        _mountHelper(iterator.next()).then(() => requestAnimationFrame(() => resolve()));\n    });\n}\n\n/**\n * Initializes a list of component modules synchronously.\n * @param componentIds list of component identifiers\n * @param callback callback function to call after succesful initialization of each component\n */\nexport async function setupComponents(\n    componentIds: TComponentId[],\n    callback?: (componentId: TComponentId) => unknown,\n): Promise<void> {\n    return new Promise((resolve) => {\n        const iterator = componentIds.entries();\n\n        async function _setupHelper(\n            iteratorResult: IteratorResult<[number, TComponentId], unknown>,\n        ): Promise<void> {\n            if (iteratorResult.done) return;\n\n            const [_, componentId] = iteratorResult.value;\n            await _setupComponent(componentId);\n            if (callback !== undefined) callback(componentId);\n\n            return _setupHelper(iterator.next());\n        }\n\n        _setupHelper(iterator.next()).then(() => requestAnimationFrame(() => resolve()));\n    });\n}\n\n/**\n * Registers syntax elements in the programming engine.\n * @param entries list of objects of component identifiers and corresponding syntax element filters\n */\nexport function registerElements(\n    entries: {\n        /** Component identifier. */\n        id: TComponentId;\n        /** List of syntax elements to register, or register all if `true`. */\n        filter: string[] | true | undefined;\n    }[],\n) {\n    registerElementSpecificationEntries(librarySpecification);\n\n    entries\n        .filter(({ filter }) => filter !== undefined)\n        .map(({ id, filter }) => {\n            if (filter === true) {\n                return { id, specification: _components[id]!.elements };\n            }\n\n            return {\n                id,\n                specification: Object.fromEntries(\n                    Object.entries(_components[id]!.elements!).filter(([elementName]) =>\n                        filter?.includes(elementName),\n                    ),\n                ),\n            };\n        })\n        .map(\n            ({ specification }) =>\n                specification as { [elementName: string]: IElementSpecification } | undefined,\n        )\n        .filter((specification) => specification !== undefined)\n        .forEach((specification) => registerElementSpecificationEntries(specification!));\n}\n\nexport { serializeComponentDependencies } from './utils';\n"],"names":["serializeComponentDependencies","components","length","DAG","rowComponent","j","colComponent","visited","visiting","unvisited","_","i","hasParents","index","_components","_mountComponent","componentId","_setupComponent","getComponent","importComponent","path","__variableDynamicImportRuntimeHelper","importComponents","componentIds","componentManifest","callback","id","component","mountComponents","resolve","iterator","_mountHelper","iteratorResult","setupComponents","_setupHelper","registerElements","entries","registerElementSpecificationEntries","librarySpecification","filter","elementName","specification"],"mappings":"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"}