{"version":3,"file":"index-2a917590.js","sources":["../../src/app/index.ts"],"sourcesContent":["import type { IAppConfig, TAppImportMap } from '@/@types/app';\nimport type {\n    IComponent,\n    IComponentDefinition,\n    IComponentDefinitionExtended,\n    TComponentId,\n} from '@/@types/components';\nimport type { TAsset } from '@/@types/core/assets';\nimport type { TI18nLang } from '@/@types/core/i18n';\n\n// -------------------------------------------------------------------------------------------------\n\nconst _importMap: TAppImportMap = {\n    lang: undefined,\n    assets: {},\n    components: {},\n};\n\n// -------------------------------------------------------------------------------------------------\n\nasync function _loadConfig(preset: number): Promise<IAppConfig> {\n    return (await import(`./config/preset-${preset}.ts`)).default;\n}\n\nfunction _updateImportMap(item: 'lang', subitem: TI18nLang): TAppImportMap;\nfunction _updateImportMap(item: 'assets', subitem: string): TAppImportMap;\nfunction _updateImportMap(item: 'components', subitem: TComponentId): TAppImportMap;\nfunction _updateImportMap(item: keyof TAppImportMap, subitem?: string): TAppImportMap {\n    if (item === 'lang') {\n        _importMap.lang = subitem as TI18nLang;\n    } else if (item === 'assets') {\n        const assets = { ..._importMap.assets };\n        assets[subitem as string] = true;\n        _importMap.assets = { ...assets };\n    } else if (item === 'components') {\n        const components = { ..._importMap.components };\n        components[subitem as TComponentId] = true;\n        _importMap.components = { ...components };\n    }\n\n    // if (import.meta.env.DEV) console.log(`${item}${subitem ? ` > ${subitem}` : ''}`);\n\n    return _importMap;\n}\n\n// -------------------------------------------------------------------------------------------------\n\nasync function init(config?: IAppConfig) {\n    if (config === undefined) {\n        config = await _loadConfig(import.meta.env.VITE_CONFIG_PRESET);\n    }\n\n    const componentManifest = (await import('@/components')).default;\n    const assetManifest = (await import('@/assets')).default;\n\n    const { importAssets, getAssets } = await import('@/core/assets');\n\n    let splashTimeStart: number;\n\n    /*\n     * Initialize the application view and mount the spalsh screen.\n     */\n\n    {\n        const { initView, mountSplash, setView, definition, injected } = await import(\n            '@/core/view'\n        );\n\n        await importAssets(\n            Object.entries(assetManifest)\n                .filter(([identifier]) => (definition.assets as string[]).includes(identifier))\n                .map(([identifier, manifest]) => ({ identifier, manifest })),\n            () => undefined,\n        );\n\n        // @ts-ignore\n        injected.assets = getAssets(definition.assets);\n\n        // Initialize view toolkit\n        await initView();\n        await mountSplash();\n        splashTimeStart = Date.now();\n        await setView('main');\n    }\n\n    /*\n     * Dynamically import components, strings, and assets asynchronously.\n     */\n\n    {\n        const { updateSplash } = await import('@/core/view');\n\n        const updateSplashData = (data: TAppImportMap) => {\n            const total = 1 + Object.keys(data.assets).length + Object.keys(data.components).length;\n            const items =\n                (data.lang !== undefined ? 1 : 0) +\n                Object.values(data.assets).filter((flag) => flag).length +\n                Object.values(data.components).filter((flag) => flag).length;\n            updateSplash((items / total) * 100);\n        };\n\n        const importItemLang = config.env.lang;\n        /** List to component Ids to import. */\n        const importListComponents = config.components.map(({ id }) => id);\n        /** List to asset Ids to import. */\n        const importListAssets = (() => {\n            try {\n                return Object.entries(componentManifest)\n                    .map(\n                        ([\n                            _,\n                            {\n                                definition: { assets },\n                            },\n                        ]) => assets,\n                    )\n                    .reduce((a, b) => [...new Set([...a, ...b])]);\n            } catch (e) {\n                return [];\n            }\n        })();\n\n        _importMap.assets = Object.fromEntries(importListAssets.map((assetId) => [assetId, false]));\n        _importMap.components = Object.fromEntries(\n            importListComponents.map((componentId) => [componentId, false]),\n        );\n\n        const { importStrings } = await import('@/core/i18n');\n        const { importComponent } = await import('@/core/config');\n        const { importAsset } = await import('@/core/assets');\n\n        await Promise.all([\n            // import ES module for i18n and load strings\n            importStrings(importItemLang).then(() =>\n                updateSplashData(_updateImportMap('lang', importItemLang)),\n            ),\n            // import ES modules for components\n            ...importListComponents.map(\n                (componentId) =>\n                    new Promise<void>((resolve) => {\n                        importComponent(componentId, componentManifest[componentId].path).then(\n                            () => {\n                                updateSplashData(_updateImportMap('components', componentId));\n                                resolve();\n                            },\n                        );\n                    }),\n            ),\n            // import asset files and load data\n            ...importListAssets.map(\n                (assetId) =>\n                    new Promise<void>((resolve) => {\n                        importAsset(assetId, assetManifest[assetId]).then(() => {\n                            updateSplashData(_updateImportMap('assets', assetId));\n                            resolve();\n                        });\n                    }),\n            ),\n        ]);\n    }\n\n    /*\n     * Collect imported components.\n     */\n\n    const { getComponent } = await import('@/core/config');\n    const componentIds = config.components.map(({ id }) => id);\n\n    /** Map of component identifier and corresponding component module. */\n    const components: Partial<Record<TComponentId, IComponent>> = Object.fromEntries(\n        componentIds.map((componentId) => [componentId, getComponent(componentId)]),\n    );\n    /** List of 2-tuples of component identifier and component definition. */\n    const componentDefinitionEntries: [TComponentId, IComponentDefinition][] = componentIds.map(\n        (componentId) => [componentId, componentManifest[componentId].definition],\n    );\n\n    /**\n     * Inject items into component modules.\n     */\n\n    {\n        const { getStrings } = await import('@/core/i18n');\n\n        // Inject i18n strings.\n        componentDefinitionEntries.forEach(\n            ([id, { strings }]) =>\n                (components[id]!.injected.i18n =\n                    Object.keys(strings).length !== 0\n                        ? getStrings(Object.keys(strings))\n                        : undefined),\n        );\n\n        // Inject asset entries.\n        componentDefinitionEntries.forEach(\n            ([id, { assets }]) =>\n                (components[id]!.injected.assets =\n                    assets !== undefined\n                        ? (getAssets(assets) as { [identifier: string]: TAsset })\n                        : undefined),\n        );\n\n        // Inject feature flags.\n        componentDefinitionEntries.forEach(\n            ([componentId]) =>\n                (components[componentId]!.injected.flags = config!.components.find(\n                    ({ id }) => id === componentId,\n                    // @ts-ignore\n                )?.flags),\n        );\n    }\n\n    /**\n     * Serialized list of component identifiers in which the dependent components take precedence.\n     */\n    let componentsOrdered: TComponentId[];\n\n    /*\n     * Complete the application initialization\n     */\n\n    {\n        const {\n            mountComponents,\n            setupComponents,\n            registerElements,\n            serializeComponentDependencies,\n        } = await import('@/core/config');\n\n        // Generate serialized list of component identifiers\n        componentsOrdered = serializeComponentDependencies(\n            componentDefinitionEntries\n                .map<[TComponentId, TComponentId[]]>(([id, { dependencies }]) => [\n                    id,\n                    [...new Set([...dependencies.optional, ...dependencies.required])],\n                ])\n                .map(([id, dependencies]) => ({ id, dependencies })),\n        );\n\n        // Register syntax elements as configured for each component\n        registerElements(\n            componentsOrdered.map((componentId) => {\n                return {\n                    id: componentId,\n                    // @ts-ignore\n                    filter: config.components.find(({ id }) => id === componentId)?.elements,\n                };\n            }),\n        );\n\n        // Mount components in serialized order\n        await mountComponents(componentsOrdered);\n\n        // Initialize components in serialized order\n        await setupComponents(componentsOrdered);\n\n        // Unmount the splash screen.\n        const { unmountSplash } = await import('@/core/view');\n        const splashTimeEnd = Date.now();\n        const splashTime = splashTimeEnd - splashTimeStart;\n        const splashBuffer = Math.max(import.meta.env.VITE_APP_SPLASH_MIN_DELAY - splashTime, 0);\n        setTimeout(() => unmountSplash(), splashBuffer);\n    }\n\n    if (import.meta.env.PROD) {\n        const { loadServiceWorker } = await import('./utils/misc');\n        loadServiceWorker();\n    }\n}\n\n// =================================================================================================\n\n(async function () {\n    /**\n     * if PRODUCTION mode, proceed initializing with configuration preset.\n     */\n\n    if (import.meta.env.PROD) {\n        await init();\n        return;\n    }\n\n    /**\n     * if DEVELOPMENT mode, and configuration in session storage,\n     * proceed initializing with configuration from session storage.\n     */\n\n    {\n        const config = window.sessionStorage.getItem('appConfig');\n\n        if (config !== null) {\n            await init(JSON.parse(config) as IAppConfig);\n            return;\n        }\n    }\n\n    /**\n     * if DEVELOPMENT mode, and configuration not in session storage,\n     * open configurator page.\n     * @todo currently needs refresh to go to main app page\n     */\n\n    {\n        const config = await _loadConfig(import.meta.env.VITE_CONFIG_PRESET);\n\n        const { initView, mountConfigPage, updateConfigPage } = await import('@/core/view');\n        await initView();\n\n        window.sessionStorage.setItem('appConfig', JSON.stringify(config));\n\n        const componentManifest = (await import('@/components')).default;\n        const { importComponent } = await import('@/core/config');\n        const components = Object.fromEntries(\n            await Promise.all(\n                (Object.keys(componentManifest) as TComponentId[]).map((componentId) =>\n                    importComponent(componentId, componentManifest[componentId].path).then(\n                        (component) => [componentId, component],\n                    ),\n                ),\n            ),\n        ) as Record<TComponentId, IComponent>;\n        const componentDefinitions = Object.fromEntries(\n            Object.entries(componentManifest).map<[TComponentId, IComponentDefinitionExtended]>(\n                ([componentId, { definition }]) => [\n                    componentId as TComponentId,\n                    { ...definition, elements: components[componentId as TComponentId].elements },\n                ],\n            ),\n        ) as Record<TComponentId, IComponentDefinition>;\n\n        await mountConfigPage(\n            { ...config },\n            Object.fromEntries(\n                (\n                    Object.entries(componentDefinitions) as [TComponentId, IComponentDefinition][]\n                ).map(([componentId, definition]) => [\n                    componentId,\n                    {\n                        ...definition,\n                        elements: components[componentId]?.elements,\n                    },\n                ]),\n            ),\n            (config: IAppConfig) =>\n                requestAnimationFrame(() => {\n                    window.sessionStorage.setItem('appConfig', JSON.stringify(config));\n                    updateConfigPage(config);\n                }),\n        );\n    }\n})();\n"],"names":["_importMap","_loadConfig","preset","__variableDynamicImportRuntimeHelper","__vitePreload","_updateImportMap","item","subitem","assets","components","init","config","componentManifest","assetManifest","importAssets","getAssets","splashTimeStart","initView","mountSplash","setView","definition","injected","n","identifier","manifest","updateSplash","updateSplashData","data","total","items","flag","importItemLang","importListComponents","id","importListAssets","_","a","b","assetId","componentId","importStrings","importComponent","importAsset","resolve","getComponent","componentIds","componentDefinitionEntries","getStrings","strings","_a","componentsOrdered","mountComponents","setupComponents","registerElements","serializeComponentDependencies","dependencies","unmountSplash","splashTime","splashBuffer","loadServiceWorker"],"mappings":"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"}